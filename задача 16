using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace задача_16
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyLinkedList<int> list = new MyLinkedList<int>();
            Console.WriteLine("добавляем элементы:");
            list.Add(10);
            list.Add(20);
            list.Add(30);
            list.Add(40);
            list.Add(50);

            Console.WriteLine($"до:");
            PrintMas(list);

            list.remove(30);
            Console.WriteLine($"После удален:");
            PrintMas(list);

            Console.WriteLine($"первый элемен {list.removeFir()}");
            PrintMas(list);
        }

        public static void PrintMas(MyLinkedList<int> mas)
        {
            for (int i = 0; i < mas.Size(); i++)
            {
                Console.WriteLine($"{i + 1}-й элемент: {mas.get(i)} ");
            }
        }

        public class Node<T>
        {
            public Node<T> next;
            public Node<T> prev;
            public T data;

            public Node(T data)
            {
                this.data = data;
                next = null;
                prev = null;
            }
        }

        public class MyLinkedList<T>
        {
            private Node<T> first;
            private Node<T> last;
            private int size;

            public MyLinkedList()
            {
                size = 0;
                first = null;
                last = null;
            }

            public MyLinkedList(T[] a)
            {
                foreach (var item in a)
                {
                    Add(item);
                }
            }

            public void Add(T item)
            {
                Node<T> newUzel = new Node<T>(item);

                if (size == 0)
                {
                    first = newUzel;
                    last = newUzel;
                }
                else
                {
                    last.next = newUzel;
                    newUzel.prev = last;
                    last = newUzel;
                }
                size++;
            }

            public void AddAll(T[] a)
            {
                foreach (var item in a)
                {
                    Add(item);
                }
            }

            public void Clear()
            {
                Node<T> uzel = first;
                while (uzel != null)
                {
                    Node<T> next = uzel.next;
                    uzel.prev = null;
                    uzel.next = null;
                    uzel = next;
                }
                first = null;
                last = null;
                size = 0;
            }

            public bool Cont(T obj)
            {
                Node<T> uzel = first;
                while (uzel != null)
                {
                    if (Equals(uzel.data, obj))
                        return true;
                    uzel = uzel.next;
                }
                return false;
            }

            public bool ContAll(T[] a)
            {
                foreach (var item in a)
                {
                    if (!Cont(item))
                        return false;
                }
                return true;
            }

            public bool IsEmp()
            {
                return size == 0;
            }

            public void remove(T obj)
            {
                Node<T> uzel = first;
                while (uzel != null)
                {
                    if (Equals(uzel.data, obj))
                    {
                        if (uzel.prev != null)
                            uzel.prev.next = uzel.next;
                        else
                            first = uzel.next;

                        if (uzel.next != null)
                            uzel.next.prev = uzel.prev;
                        else
                            last = uzel.prev;

                        size--;
                        return;
                    }
                    uzel = uzel.next;
                }
            }

            public void RemAll(T[] a)
            {
                foreach (var item in a)
                {
                    remove(item);
                }
            }

            public void retaAll(T[] a)
            {
                Node<T> uzel = first;
                while (uzel != null)
                {
                    bool found = false;
                    foreach (var item in a)
                    {
                        if (Equals(uzel.data, item))
                        {
                            found = true;
                            break;
                        }
                    }

                    Node<T> next = uzel.next;
                    if (!found)
                    {
                        remove(uzel.data);
                    }
                    uzel = next;
                }
            }

            public int Size()
            {
                return size;
            }

            public void add(int index, T item)
            {
                if (index == size)
                {
                    Add(item);
                    return;
                }

                Node<T> newUzel = new Node<T>(item);

                if (index == 0)
                {
                    newUzel.next = first;
                    first.prev = newUzel;
                    first = newUzel;
                }
                else
                {
                    Node<T> uzel = GetNode(index);
                    newUzel.prev = uzel.prev;
                    newUzel.next = uzel;
                    uzel.prev.next = newUzel;
                    uzel.prev = newUzel;
                }
                size++;
            }

            private Node<T> GetNode(int index)
            {
                Node<T> uzel;
                if (index < size / 2)
                {
                    uzel = first;
                    for (int i = 0; i < index; i++)
                    {
                        uzel = uzel.next;
                    }
                }
                else
                {
                    uzel = last;
                    for (int i = size - 1; i > index; i--)
                    {
                        uzel = uzel.prev;
                    }
                }
                return uzel;
            }

            public void AddALl(int index, T[] a)
            {
                foreach (var item in a)
                {
                    add(index++, item);
                }
            }

            public T get(int index)
            {
                return GetNode(index).data;
            }

            public int indexOF(T o)
            {
                Node<T> uzel = first;
                int index = 0;
                while (uzel != null)
                {
                    if (Equals(uzel.data, o))
                        return index;
                    uzel = uzel.next;
                    index++;
                }
                return -1;
            }

            public int lastIndOf(T o)
            {
                Node<T> uzel = last;
                int index = size - 1;
                while (uzel != null)
                {
                    if (Equals(uzel.data, o))
                        return index;
                    uzel = uzel.prev;
                    index--;
                }
                return -1;
            }

            public T Remove(int index)
            {
                Node<T> uzel = GetNode(index);
                T data = uzel.data;

                if (uzel.prev != null)
                    uzel.prev.next = uzel.next;
                else
                    first = uzel.next;

                if (uzel.next != null)
                    uzel.next.prev = uzel.prev;
                else
                    last = uzel.prev;

                size--;
                return data;
            }

            public void set(int index, T e)
            {
                GetNode(index).data = e;
            }

            public T[] subLis(int beg, int end)
            {
                T[] res = new T[end - beg];
                Node<T> uzel = GetNode(beg);

                for (int i = 0; i < end - beg; i++)
                {
                    res[i] = uzel.data;
                    uzel = uzel.next;
                }

                return res;
            }

            public T element()
            {
                return first.data;
            }

            public bool offer(T e)
            {
                try
                {
                    Add(e);
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            public T peek()
            {
                if (size == 0) return default(T);
                return first.data;
            }

            public T poll()
            {
                if (size == 0) return default(T);
                return removeFir();
            }

            public void AddFir(T item)
            {
                add(0, item);
            }

            public void addLast(T item)
            {
                Add(item);
            }

            public T getFir()
            {
                return first.data;
            }

            public T getLas()
            {
                return last.data;
            }

            public bool offFir(T item)
            {
                try
                {
                    AddFir(item);
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            public bool offLAst(T item)
            {
                try
                {
                    addLast(item);
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            public T pop()
            {
                return removeFir();
            }

            public void push(T item)
            {
                AddFir(item);
            }

            public T peekLast()
            {
                if (size == 0) return default(T);
                return last.data;
            }

            public T pollFir()
            {
                return poll();
            }

            public T pollLas()
            {
                if (size == 0) return default(T);
                return removelas();
            }

            public T removelas()
            {
                T data = last.data;
                remove(data);
                return data;
            }

            public T removeFir()
            {
                T data = first.data;
                remove(data);
                return data;
            }

            public bool remLasOC(T obj)
            {
                int index = lastIndOf(obj);
                if (index != -1)
                {
                    Remove(index);
                    return true;
                }
                return false;
            }

            public bool remFirOc(T obj)
            {
                int index = indexOF(obj);
                if (index != -1)
                {
                    Remove(index);
                    return true;
                }
                return false;
            }
        }
    }
}
