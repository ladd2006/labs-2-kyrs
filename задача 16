using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace задача_16
{
    internal class Program
    {
        static void Main(string[] args)
        {
                      
            MyLinkedList<int> list = new MyLinkedList<int>();
            Console.WriteLine("добавляем элементы:");
            list.Add(10);
            list.Add(20);
            list.Add(30);
            list.Add(40);
            list.Add(50);     
            Console.WriteLine($"до:");
            PrintMas(list);
            list.remove(30);
            Console.WriteLine($"После удален:");
            PrintMas(list);
            Console.WriteLine($"первый элемен {list.removeFir()}");
            PrintMas(list);
     

            
        }
        public static void PrintMas(MyLinkedList<int> mas)
        {
            for (int i = 0; i < mas.Size(); i++)
            {
                Console.WriteLine($"{i + 1}-й элемент: {mas.get(i)} ");
            }
        }
        public class MyLinkedList<T>
        {
            public int fir;
            public int las;
            public int size;
            public T[] items;

            public MyLinkedList()
            {
                items = new T[4];
                size = 0;
                fir = 0;
                las = 0;
            }
            public MyLinkedList(T[] a)
            {
                items = new T[a.Length];
                Array.Copy(a, items, a.Length);
                size = a.Length;
                fir = 0;
                las = size - 1;
            }

            
            public void Add(T item)
            {
                if (items.Length < size + 1)  
                {
                    int newCapacity = items.Length == 0 ? 4 : items.Length * 2;
                    T[] tempmas = new T[newCapacity];
                    Array.Copy(items, tempmas, items.Length);
                    items = tempmas;
                }
                items[size] = item;
                las = size;
                size++;
                fir = 0;
            }
            public void AddAll(T[] a)
            {
                if (items.Length < size + a.Length)
                {
                    T[] tempsmas = new T[size + a.Length];
                    Array.Copy(items, tempsmas, items.Length);
                    items = tempsmas;
                }
                for (int i = 0; i < a.Length; i++)
                {
                    Add(a[i]);
                }
            }
            public void Clear()
            {
                if (size == 0)
                {
                    Console.WriteLine("Список и так пустой");

                }
                if (size != 0)
                {
                    for (int i = 0; i < size; i++)
                    {
                        items[i] = default(T);
                    }

                }

            }
            public bool Cont(object obj)
            {
                if (size == 0) return false;
                for (int i = 0; i < size; i++)
                {
                    if (Equals(obj, items[i])) return true;
                }
                return false;
            }
            public bool ContAll(T[] a)
            {
                if (size == 0) return false;
                int count = 0;
                for (int i = 0; i < a.Length; i++)
                {
                    for (int j = 0; j < size; j++)
                    {
                        if (Equals(items[j], a[i])) count++;
                    }
                }
                if (count == a.Length)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            public bool IsEmp()
            {
                if (size == 0) return true;
                return false;
            }
            public void remove(object obj)
            {
                if (size == 0) return;

                for (int i = 0; i < size; i++)
                {
                    if (Equals(obj, items[i]))
                    {
                        
                        if (i < size - 1)
                        {
                            
                            Array.Copy(items, i + 1, items, i, size - i - 1);
                        }                       
                        size--;                       
                        if (size < items.Length)
                        {
                            items[size] = default(T);
                        }
                        las = size > 0 ? size - 1 : 0;

                        return;
                    }
                }
            }
            public void RemAll(T[] a)
            {
                if (IsEmp()) return;
                for (int i = 0; i < a.Length; i++)
                {
                    remove(a[i]);
                }

            }
            public void retaAll(T[] a)
            {
                bool have = false;
                T[] condidati = new T[size];
                int condind = 0;
                for (int i = 0; i < size; i++)
                {
                    for (int j = 0; j < a.Length; j++)
                    {
                        if (Equals(items[j], a[i]))
                        {
                            have = true;
                        }
                    }
                    if (!have)
                    {
                        condidati[condind++] = items[i];
                    }
                }
                for (int i = 0; i < condind + 1; i++)
                {
                    remove(condidati[i]);
                }
            }
            public int Size()
            {
                return size;
            }
            public void add(int ind, T item)
            {
                if (items.Length <= size + 1)
                {
                    int tempsiz = 0;
                    T[] tempsmas = new T[size + 2];
                    for (int i = 0; i < ind; i++)
                    {
                        tempsmas[tempsiz++] = items[i];
                    }
                    for (int i = ind + 1; i < size; i++)
                    {
                        tempsmas[tempsiz++] = items[i];
                    }
                    items = tempsmas;
                    items[ind] = item;
                    size++;
                    las = size - 1;
                }
                else
                {
                    int tempsiz = 0;
                    T[] tempsmas = new T[size];
                    for (int i = 0; i < ind; i++)
                    {
                        tempsmas[tempsiz++] = items[i];
                    }
                    for (int i = ind + 1; i < size; i++)
                    {
                        tempsmas[tempsiz++] = items[i];
                    }
                    items = tempsmas;
                    items[ind] = item;
                    size++;
                    las = size - 1;
                }
            }
            public void AddALl(int ind, T[] a)
            {

                for (int i = 0; i < a.Length; i++)
                {
                    add(ind, a[i]);
                    ind++;
                }

            }
            public T get(int ind)
            {

                return items[ind];
            }
            public int indexOF(object o)
            {
                for (int i = 0; i < size; i++)
                {
                    if (Equals(o, items[i])) return i;
                }
                return -1;
            }
            public int lastIndOf(object o)
            {
                for (int i = size - 1; i >= 0; i--)
                {
                    if (Equals(o, items[i])) return i;
                }
                return -1;
            }
            public T Remove(int ind)
            {
                T removedItem = items[ind];


                for (int j = ind; j < size - 1; j++)
                {
                    items[j] = items[j + 1];
                }
                size--;
                if (size < items.Length)
                {
                    items[size] = default(T);
                }


                las = size > 0 ? size - 1 : 0;

                return removedItem;
            }
            public void set(int ind, T e)
            {
                items[ind] = e;
            }
            public T[] subLis(int beg, int end)
            {
                T[] res = new T[end - beg];
                int indRes = 0;
                for (int i = beg; i < end; i++)
                {
                    res[indRes++] = items[i];
                }
                return res;
            }
            public T element()
            {
                return items[0];
            }
            public bool offer(T e)
            {
                try
                {
                    Add(e);
                    return true;
                }
                catch (Exception)
                {
                    return false;
                }
            }
            public T peek()
            {
                if (size == 0) return default(T);
                return items[0];
            }
            public T poll()
            {
                T res = element();
                remove(items[0]);
                return res;
            }
            public void AddFir(T item)
            {
                add(fir, item);
            }
            public void addLast(T item)
            {
                Add(item);
            }
            public T getFir()
            {
                return items[fir];
            }
            public T getLas()
            {
                return items[las];
            }
            public bool offFir(T item)
            {
                try
                {
                    AddFir(item);
                    return true;
                }
                catch (Exception)
                {
                    return false;
                }
            }
            public bool offLAst(T item)
            {
                try
                {
                    addLast(item);
                    return true;
                }
                catch (Exception)
                {
                    return false;
                }
            }
            public T pop()
            {
                T res = items[fir];
                remove(items[fir]);
                return res;
            }
            public void push(T item)
            {
                AddFir(item);
            }
            public T peekLast()
            {
                if (size ==0) return default(T);
                return items[las];
            }
            public T pollFir()
            {
                if (size == 0) return default(T);
                T res = items[fir];
                remove(items[fir]);
                return res;
            }
            public T pollLas()
            {
                if (size == 0) return default(T);
                T res = items[las];
                remove(items[las]);
                return res;
            }
            public T removelas()
            {
                T res = items[las];
                remove(items[las]);
                return res;
            }
            public T removeFir()
            {
                T res = items[fir];
                remove(items[fir]);
                return res;
            }
            public bool remLasOC(object obj)
            {
                if (Cont(obj))
                {
                    remove(items[lastIndOf(obj)]);
                    return true;
                }
                else
                {
                    return false;
                }
            }
            public bool remFirOc(object obj)
            {
                if (Cont(obj))
                {
                    remove(items[indexOF(obj)]);
                    return true;
                }
                else
                {
                    return false;
                }
            }




        }

    }
}


