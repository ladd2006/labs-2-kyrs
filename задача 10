using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace задача_10
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyVector<int> vector = new MyVector<int>();

            
            vector.add(10);
            vector.add(20);
            vector.add(30);
            vector.add(40);

            Console.WriteLine("Вектор:");
            PrintVector(vector);

            
            vector.add(2, 25);
            Console.WriteLine("После вставки 25 на позицию 2:");
            PrintVector(vector);

            int[] newElements = { 50, 60, 70 };
            vector.AddAll(newElements);
            Console.WriteLine("После");
            PrintVector(vector);

            // Проверяем поиск элементов
            Console.WriteLine($"Содержит 25: {vector.Contains(25)}");
            Console.WriteLine($"Индекс 40-ка: {vector.indexOf(40)}");
            Console.WriteLine($"Последний элемент: {vector.lastElement()}");

            // Удаляем элемент
            vector.remove(25);
            Console.WriteLine("После удаления 25:");
            PrintVector(vector);
        }

        static void PrintVector<T>(MyVector<T> vector)
        {
            for (int i = 0; i < vector.Size(); i++)
            {
                Console.Write(vector.get(i) + " ");
            }
            Console.WriteLine();
        }
    }
    
    public class MyVector<T>
    {
        private T[] elementData;
        private int elementCount;
        private int CapacityIncrement;

        private const int Default = 10;
        public MyVector(int initialCapacity,int capacityIncrement)
        {
            elementData = new T[initialCapacity];
            CapacityIncrement = capacityIncrement;
            elementCount = 0;
        }

        public MyVector(int initialCapacity)
        {
            elementData = new T[initialCapacity];
            CapacityIncrement = 0;
            elementCount = 0;
           

        }

        public MyVector()
        {
            elementData = new T[Default];
            CapacityIncrement = 0;
            elementCount = 0;
        }
        public MyVector(T[] a)
        {
            elementData = a;
            CapacityIncrement += a.Length;
            elementCount = a.Length;

        }
        public void add(T e)
        {
           
            if(elementCount+1 > elementData.Length)       
            {

                if (CapacityIncrement > 0)
                {
                    T[] newVec = new T[(int)(elementData.Length + CapacityIncrement)];
                    for (int i = 0; i < elementCount; i++)
                    {
                        newVec[i] = elementData[i];

                    }
                    elementData = newVec;
                   


                }
                else
                {

                    T[] newwVec = new T[elementData.Length * 2];
                    for (int i = 0; i < elementCount; i++)
                    {
                        newwVec[i] = elementData[i];
                        elementData = newwVec;
                        

                    }
                }
            }
            elementData[elementCount] = e;
            elementCount++;

        }
        public void AddAll(T[] a)
        {
            if (elementData.Length < elementCount + a.Length)
            {
                T[] NewVec = new T[elementCount + a.Length];
                for (int i = 0; i < elementCount; i++)
                {
                    NewVec[i] = elementData[i];
                }
                elementData = NewVec;
            }

            for (int i = 0; i < a.Length; i++)
            {
                elementData[elementCount + i] = a[i];
            }
            elementCount += a.Length;
        }

        public void Clear()
        {
            for (int i = 0; i < elementData.Length - 1; i++)
            {
                elementData[i] = default(T);
            }
            elementCount = 0;
        }
        public bool Contains(object a)
        {
            
            for(int i =0; i < elementCount - 1;i++)
            {
                if(Equals(a,elementData[i]))return true;
                
            }
            return false;
        }
        public bool ContainsAll(T[] a)
        {
            int count = 0;
            for(int i = 0;i<a.Length;i++)
            {
                for(int j = 0;j < elementCount;j++)
                {
                    if (Equals(a[i], elementData[j])) count++;
                }
            }
            if(count == a.Length) return true;
            return false;

           
        }
        public bool IsEmpty()
        {
            if(elementCount == 0) return true;
            return false;

            
        }
        public void remove(object a)
        {
            for(int i = 0;i < elementCount;i++)
            {
                if (Equals(elementData[i],a))
                {
                    elementData[i] = default(T) ;
                    int b = i + 1;
                    T[] temp1 = new T[elementCount - 1];
                    for(int j = 0;j < i;i++)
                    {
                        temp1[j] = elementData[j];
                    }
                    for(int j = i + 1;j < elementCount - i;j++)
                    {
                        temp1[b] = elementData[j];
                    }
                    elementData = temp1;
                    elementCount--;
                }
            }
        }
        public void removeAll(T[] a)
        {
            int len = a.Length;
            for(int i = 0;i < len;i++)
            {
                remove(a[i]);
            }
        }
        public void retainAll(T[] a)
        {
            for (int i = elementCount - 1; i >= 0; i--)
            {
                bool found = false;
                for (int j = 0; j < a.Length; j++)
                {
                    if (Equals(elementData[i], a[j]))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    remove(elementData[i]);
                }
            }
        }
        public int Size()
        {
            return elementCount;    
        }
        public T[] toArray(T[] a)
        {
            return elementData;
        }
        public void add(int ind, T e)
        {

            for(int i = elementCount;i > ind;i--)
            {
                elementData[i] = elementData[i - 1];
            }
            elementData[ind] = e;
            elementCount++;

        }
        public void AddAll(int index, T[] a)
        {
            if(elementData.Length < elementCount + a.Length)
            {
                T[] temp = new T[elementData.Length + a.Length];
                for(int i =0;i < elementCount;i++)
                {
                    temp[i] = elementData[i];
                }
                elementData = temp;
               
            }
            for (int i = elementCount - 1; i >= index; i--)
            {
                elementData[i + a.Length] = elementData[i];
            }
            for (int i = 0; i < a.Length; i++)
            {
                elementData[index + i] = a[i];
            }
            elementCount += a.Length;
        }
        public T get(int ind)
        {
            return elementData[ind];
        }
        public int indexOf(object o)
        {
            for(int i = 0;i < elementCount;i++)
            {
                if (Equals(elementData[i], o)) return i;
            }
            return -1;
        }
        public int lastIndexOf(object o)
        {
            for(int i = elementCount - 1;i >= 0;i--)
            {
                if(Equals(elementData[i], o))  return i;
            }
            return -1;
        }
        public T remove(int index)
        {
            T res = elementData[index];
            remove(elementData[index]);
            return res;
        }
        public void set(int index,T e)
        {
            elementData[index] = e;
        }
        public T[] subList(int from, int to)
        {
            T[] res = new T[to - from];
         
            for(int i = from;i < to;i++)
            {
                res[i - from] = elementData[i];
            }
            return res;

        }
        public T firstElement()
        {
            return elementData[0];
        }
        public T lastElement()
        {
            return elementData[elementCount - 1];
        }
        public void removeElementAt(int pos)
        {
            remove(elementData[pos]);
        }
        public void removeRange(int beg, int end)
        {
            for(int i =beg;i<end;i++)
            {
                remove(elementData[i]);
            }
        }


    }
}
