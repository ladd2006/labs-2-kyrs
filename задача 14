using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading.Tasks;

namespace задача_14
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyArrrayDeque<string> deque = new MyArrrayDeque<string>();

          
            deque.add("apple");
            deque.add("banana");
            deque.add("cherry");
            deque.add("date");
            deque.add("elderberry");
            Console.WriteLine();

            Console.WriteLine("Исходная очередь:");
            deque.PrintMas();
            
            string[] retainArray = { "banana", "date" };
            deque.remove("apple");
           
            Console.WriteLine("Очередь после retainAll:");
            deque.PrintMas();
            
        }
      
        public class MyArrrayDeque<T>
        {
            public T[] elements;
            public int head,tail;
           
            public MyArrrayDeque()
            {
                elements = new T[16];
                head = 0;tail = -1;
            }
            public MyArrrayDeque(T[] a)
            {
                elements = new T[a.Length];
                Array.Copy(a,elements,a.Length);
                head = 0;
                tail = a.Length - 1;
                
            }
            public MyArrrayDeque(int numElements)
            {
                elements = new T[numElements];
                head = 0;
                tail = -1;
            }
            public void add(T e)
            {
                if (elements.Length <= size())
                {
                    T[] temp = new T[elements.Length * 2];
                    Array.Copy(elements, temp, elements.Length);
                    elements = temp;                    
                }
                tail++;
                elements[tail] = e;
               

            }
            public void addAll(T[] a)
            {
                if(elements.Length < (tail - head + a.Length))
                {
                    T[] temp = new T[elements.Length + a.Length];
                    Array.Copy(elements,temp, elements.Length); 
                    elements = temp;
                }
                for(int i = 0; i < a.Length; i++)
                {
                    elements[tail++] = a[i];
                }
                tail += a.Length;
            }
            public bool contains(object o)
            {
                for(int i = 0;i < tail+1;i++)
                {
                    if(Equals(o,elements[i])) return true;
                }
                return false;   
            }
            public bool containsAll(T[] a )
            {
                int count = 0;
                for(int i = 0;i < a.Length;i++)
                {
                    if(contains(a[i])) count++;
                }
                if(count == elements.Length)
                {
                    return true;
                }
                return false;
            }
            public bool isEmpty()
            {
                if(tail == 0) return true;
                return false;
            }
            public void remove(object o)
            {
                for (int i = head; i <= tail; i++)
                {
                    if (Equals(elements[i], o))
                    {
                        
                        for (int j = i; j < tail; j++)
                        {
                            elements[j] = elements[j + 1];
                        }

                        
                        elements[tail] = default(T);
                        tail--;

                        
                        if (tail < head)
                        {
                            head = 0;
                            tail = 0;
                        }

                        break; 
                    }
                }
            }
            public void retainAll(T[] a)
            {
                List<T> toRemove = new List<T>();
                bool modified = false;

                
                for (int i = head; i <= tail; i++)
                {
                    bool found = false;
                    foreach (T item in a)
                    {
                        if (Equals(elements[i], item))
                        {
                            found = true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        toRemove.Add(elements[i]);
                       
                    }
                }

                
                foreach (T item in toRemove)
                {
                    remove(item);
                }

               
            }
            public int size()
            {
                if (isEmpty()) return 0;
                return tail-head + 1;
            }
            public T element()
            {
                return elements[head];
            }
            public bool offer(T obj)
            {
                try
                {
                    add(obj);
                    return true;
                }
                catch(Exception)
                {
                    return false;
                }
            }
            public T peek()
            {
                if(isEmpty())
                {
                    return default(T);
                }
               return elements[head];
            }
            public T poll()
            {
                             
               T res = elements[head];
                remove(elements[head]);
                return res;
            }
            public void AddFirst(T obj)
            {
                if (size() >= elements.Length)
                {
                    T[] temp = new T[size() + 1];
                    Array.Copy(elements, 0, temp, 1, size());
                    elements = temp;
                    tail = size();
                    head = 0;

                }
                else
                {
                    for (int i = tail; i >= head; i--)
                    {
                        elements[i + 1] = elements[i];
                    }
                    tail++;
                }
                elements[head] = obj;
            }
            public void AddLast(T obj)
            {
                add(obj);
            }
            public T getFirst()
            {
                return elements[head];
            }
            public T getLast()
            {
                return elements[tail];
            }
            public bool offerFirst(T obj)
            {
                try
                {
                    AddFirst(obj);
                    return true;
                }
                catch(Exception)
                {
                    return false;
                }
            }
            public bool offerLast(T obj)
            {
                try
                {
                    add(obj);
                    return true;
                }
                catch(Exception)
                {
                    return false;
                }
            }
            public T pop()
            {
                T res = elements[head];
                remove(elements[head]);
                return res;
            }
            public void push(T obj)
            {
                AddFirst(obj);
            }
            public T peekFirst()
            {
                try
                {
                    return elements[head];
                }
                catch(Exception)
                {
                    return default(T);
                }
            }
            public T peekLast()
            {
                try
                {
                    return elements[tail];
                }
                catch (Exception)
                {
                    return default(T);
                }
            }
            public T pollF()
            {
                try
                {
                    return pop();

                }
                catch(Exception)
                {
                    return default(T);
                }
            }
            public T pollL()
            {
                try
                {
                    T res = elements[tail];
                    remove(elements[tail]);
                    return res;
                }
                catch(Exception)
                {
                    return default(T);
                }
            }
            public void removeFirst()
            {
                pop();
            }
            public void removelast()
            {
                pollL();
            }
            public bool removelasOc(object o)
            {

                for (int i = tail; i >= head; i--)
                {
                    if (Equals(elements[i], o))
                    {
                        remove(elements[i]);
                        return true;

                    }
                }
                return false;
               
                
            }
            public bool removFirOc(object o)
            {
                for (int i = head; i <= tail; i++)
                {
                    if (Equals(elements[i], o))
                    {
                        remove(elements[i]);
                        return true;

                    }
                }
                return false;
            }
            public void PrintMas()
            {
                for(int i = head;i < size(); i++)
                {
                    Console.WriteLine($"{i + 1}: {elements[i]}");
                }
            }





        }
    }
}
